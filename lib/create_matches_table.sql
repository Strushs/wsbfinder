-- Create the matches table
CREATE TABLE matches (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    student1_user_id UUID NOT NULL REFERENCES students(user_id) ON DELETE CASCADE, -- Reference student by UUID
    student2_user_id UUID NOT NULL REFERENCES students(user_id) ON DELETE CASCADE, -- Reference student by UUID
    created_at TIMESTAMPTZ DEFAULT timezone('utc'::text, now()) NOT NULL,
    UNIQUE (student1_user_id, student2_user_id) -- Ensure unique pairs using UUIDs
);

-- Ensure that matches are bidirectional using UUIDs
-- Note: LEAST/GREATEST might not work directly on UUIDs depending on the PostgreSQL version.
-- A check constraint or trigger might be needed for complex ordering if LEAST/GREATEST fails.
-- For simplicity, the UNIQUE constraint above often suffices if order doesn't matter or is handled application-side.
-- If strict bidirectional uniqueness (A,B) == (B,A) is needed and LEAST/GREATEST fails, consider alternative approaches.
-- Dropping the old index if it exists:
-- DROP INDEX IF EXISTS unique_match;

-- Optional: Add comments
COMMENT ON TABLE public.matches IS 'Stores match relationships between students based on their user IDs.';
COMMENT ON COLUMN public.matches.student1_user_id IS 'User ID of the first student in the match.';
COMMENT ON COLUMN public.matches.student2_user_id IS 'User ID of the second student in the match.';